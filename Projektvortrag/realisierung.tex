%-- einleitung

\section{Projektumsetzung}

In diesem Abschnitt wird beschrieben, wie das Konzept umgesetzt wurde.
Es wird erläutert, für welche Programmteile welche Programmiersprachen eingesetzt wurden. Darüber hinaus wird der Einsatz von Fremdbibliotheken erläutert.
Anschließend wird mit Hilfe den wichtigsten Programmcode-Ausschnitten die implementierung der Genetischen Algorithmen dargestellt.

\subsection{Programmiersprachen}
Durch die Trennung von Frontend und der Library ergeben sich für diese beiden Programmteile unterschiedliche Anforderungen an die Programmiersprache.\\
Die Library setzt die Genetischen Algorithmen um, die während einer Simulation mehrere tausend Berechnungen durchführt. Für diesen Zweck wurde sich für die Programmiersprache C++ entschieden.
Dabei handelt es sich um eine maschinennahe Sprache mit hohen Ausführungsgeschwindigkeiten. Allerdings ist die Entwicklung mit C++ sehr zeitaufwendig. Dadurch, dass es sich bei der Library um den zeitkritischen Teil des Projektes handelt, 
wurde sich trotz des hohen Aufwands für diese Programmiersprache entschieden.\\
Das Frontend hingegen soll lediglich die Verwendung der Library demonstrieren. In diesem Fall steht eine hohe Entwicklungsgeschwindigkeit im Mittelpunkt.
Aus diesem Grund wurde sich für Python entschieden. Diese interpretierte Sprache ist im Vergleich zu C++ langsamer, ermöglicht aber eine schnellere und unkompliziertere Enwicklung.

\subsection{Frameworks und Bibliotheken}
Eine Übersicht über die verwendeten Bibliotheken ist in Tabelle \ref{tab:bibs} zu sehen.\\
Zur Entwicklung der Library für die Genetischen Algorithmen war ein Testsystem notwendig. Mit automatisierten Test wird sichergestellt, dass entwickelter Code die angedachten Aufgaben korrekt erfüllt.
Für diesen Zweck wurde die C++ Bibliothek Catch2 eingesetzt. Bei Catch2 handelt es sich um eine sogenannte Single-Header-Library. Das bedeutet, dass der gesamte Bibliothekscode in einer Datei zu finden ist.
Dadurch war eine sehr einfache Einbindung in das Projekt möglich. Catch2 läuft unter der Boost Software License, was eine kostenlose Nutzung der Bibliothek ermöglicht.\\
Des weiteren wurde eine Bibliothek zum vizualisieren von Simualtionsergebnissen eingesetzt. Dazu wurde die sehr beliebte Matplotlib verwendet. Diese ermöglicht das einfache erstellen von Graphen in Python aber auch C++.
In diesem Projekt wurde Matplotlib nur auf der Python-Seite verwendet. Die Biliothek läfut unter der Matplotlib License, bei der es sich um eine Open-Source Lizens handelt.\\
Damit ein Python Programm überhaupt C++ Code ausführen kann, ist es notwenig Schnittstellen von C++ zu Python bereitzustellen. Dafür wurde das Python-Modul der Boost Bibliothek verwendet. Mit diesem war eine sehr schnelle Schnittstellenentwicklung möglich.
Auch die Boost Bibliothek läuft unter der Boost Software Lizence und ist dadurch für eine kostenlose Nutzung freigegeben.
\begin{table}
\caption{Verwendeten Bibliotheken}
\begin{tabular}{|l|l|l|l|}
 Name & Version & Anwendung & Lizenz \\ 
\hline
 Catch2 & 2.13 & Unit-Tests der Library & Boost Software License \\  
 Matplotlib & 3.2 & Visualisierung der Experimente & Matplotlib License \\
 Boost & 1.7 & Schnittstelle zwischen C++ und Python & Boost Software License    
\end{tabular}
\label{tab:bibs}
\end{table}

\subsection{Individuen und Populationen}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img/Vortrag/uml.png}
\caption{Klassendiagramm Individuum und Population}
\label{fig:klassendiagramm}
\end{figure}


\subsection{Bewertungs und Fitnessfunktion}
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Beispiel einer Ratingfunktion}, firstnumber=1, captionpos=b, label=lst:rating]
double func_rating(int idx_start, vector<int> chromosome, vector<vector<int>> distances){
	int city_a, city_b;
	int rating = 0;
	costs += get_distance(idx_start, chromosome.at(0), distances);
	for (unsigned int i = 0; i < chromosome.size() - 1; ++i) {
		city_a = chromosome.at(i);
		city_b = chromosome.at(i + 1);
		rating += get_distance(city_a, city_b, distances);
	}
	rating += get_distance(chromosome.at(chromosome.size() - 1), idx_start, distances);
	return rating;
}
\end{lstlisting}
\end{minipage}
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Beispiel einer Fitnessfunktion}, firstnumber=1, captionpos=b, label=lst:fitness]
double func_fitness(double rating){
	return -rating;
}
\end{lstlisting}
\end{minipage}
\subsection{Marriage-Algorithmus}
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Marriage-Roulette Algorithmus}, firstnumber=1, captionpos=b, label=lst:marriage]
pair<int, int> marriage_roulette_reversed(Population &population) {
	pair<int, int> pair = make_pair(-1, -1);
	int sum = 0;
	int worst_fitness_of_population = (int) population.get_lowest_fitness_individual().get_last_calculates_fitness();
	for (auto &it : population.get_individuals()) {
		sum += (int) it.get_last_calculates_fitness() - worst_fitness_of_population;
	}
	int value_p1 = random(sum);
	int value_p2 = random(sum);

	int value = 0;
	for (unsigned int current_idx = 0; current_idx < population.size(); ++current_idx) {
		value += (int) population.get_individuals().at(current_idx).get_last_calculates_fitness() - worst_fitness_of_population;
		if (value_p1 <= value && pair.first < 0) {
			pair.first = current_idx;
		}
		if (value_p2 <= value && pair.second < 0) {
			pair.second = current_idx;
		}
	}
	return pair;
}
\end{lstlisting}
\end{minipage}
\begin{center}
\begin{tabular}{|l|l|l|}
 Individuum & Fitness & Delta \\ 
\hline
 1 & -1180 & 820 \\  
 2 & -1680 & 320 \\  
 3 & -1860 & 140 \\  
 4 & -1880 & 120 \\  
 5 & -2000 & 0 \\  
\end{tabular}
\end{center}

\subsection{Crossover-Algorithmen}

\subsubsection{Partialliy-Matched-Crossover}
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Partially-Matched-Crossover}, firstnumber=1, captionpos=b, label=lst:pmx]
void partially_matched_crossover(Individual &p1, Individual &p2, Individual &c1, Individual &c2) { 
	int length = p1.get_size();
	int interval_border_left, interval_border_right = calc_two_random_interval_borders(length);

	for (int i = 0; i < length; ++i) {
		if (i < interval_border_left || i >= interval_border_right) {
			c1.update_chromosome(p1.get_chromosome().at(i), i);
			c2.update_chromosome(p2.get_chromosome().at(i), i);
		} else {
			c1.update_chromosome(p2.get_chromosome().at(i), i);
			c2.update_chromosome(p1.get_chromosome().at(i), i);
		}
	}

	duplicate_correction_pmx(p1, p2, c1);
	duplicate_correction_pmx(p2, p1, c2);
}
\end{lstlisting}
\end{minipage}
\subsubsection{Order-Crossover}
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Order-Crossover}, firstnumber=1, captionpos=b, label=lst:ox]
void order_crossover(Individual &p1, Individual &p2, Individual &c1, Individual &c2) {
	int length = p1.get_size();
	int interval_border_left, interval_border_right = calc_two_random_interval_borders(length);

	unordered_map<int, int> map_p1, map_p2;
	for (int i = interval_border_left; i < interval_border_right; ++i) {
		map_p1.insert(pair<int, int>(p1.get_chromosome().at(i), i));
		map_p2.insert(pair<int, int>(p2.get_chromosome().at(i), i));
	}
	vector<int> cache1, cache2;
	set_duplicate_flags(map_p2, c1, p1, cache1, interval_border_left, interval_border_right);
	set_duplicate_flags(map_p1, c2, p2, cache2, interval_border_left, interval_border_right);
	copy_values(c1, cache1, interval_border_left);
	copy_values(c2, cache2, interval_border_left);

	for (int j = interval_border_left; j < interval_border_right; ++j) {
		if (c1.get_chromosome().at(j) == DUPLICATE_FLAG) {
			c1.update_chromosome(p2.get_chromosome().at(j), j);
		}
		if (c2.get_chromosome().at(j) == DUPLICATE_FLAG) {
			c2.update_chromosome(p1.get_chromosome().at(j), j);
		}
	}
}
\end{lstlisting}
\end{minipage}
\subsubsection{Cycle-Crossover-One-Cycle}
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Cycle-Crossover-One-Cycle}, firstnumber=1, captionpos=b, label=lst:cxo]
void cycle_crossover_one_cycle(Individual &p1, Individual &p2, Individual &c1, Individual &c2) {
	vector<bool> index_flags(p1.get_size(), false);
	Cycle cycle;
	int cycle_start_idx = random(p1.get_size());
	fill_empty_cycle_with_tuples(cycle, cycle_start_idx, p1, p2, index_flags)
	int tupleCounter = 0;
	for (int i = 0; (unsigned int) i < index_flags.size(); ++i) {
		bool flag = index_flags.at(i);
		if (flag) {
			Tuple &t = cycle.at(tupleCounter);
			tupleCounter++;
			c1.update_chromosome(get<1>(t), get<0>(t));
			c2.update_chromosome(get<2>(t), get<0>(t));
		} else {
 			c1.update_chromosome(p2.get_chromosome().at(i), i);
			c2.update_chromosome(p1.get_chromosome().at(i), i);
		}
	}
}
\end{lstlisting}
\end{minipage}

\subsubsection{Cycle-Crossover-All-Cycles}
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Cycle-Crossover-All-Cycles}, firstnumber=1, captionpos=b, label=lst:cxa]
void cycle_crossover_all_cycles(Individual &p1, Individual &p2, Individual &c1, Individual &c2) {
	vector<bool> index_flags(p1.get_size(), false);
	vector<Cycle> cycles;
	for (int cycle_start_idx = 0; cycle_start_idx < p1.get_size(); ++cycle_start_idx) {
		Cycle cycle;
		if (!index_flags.at(cycle_start_idx)) {
			fill_empty_cycle_with_tuples(cycle, cycle_start_idx, p1, p2, index_flags)
		}
		cycles.push_back(cycle);
		}
	}
	for (int i = 0; (unsigned int) i < cycles.size(); ++i) {
		bool cross_copy = i % 2 != 0;
		Cycle &cycle = cycles.at(i);
		for (Tuple &t : cycle) {
			if (cross_copy) {
				c1.update_chromosome(get<2>(t), get<0>(t));
				c2.update_chromosome(get<1>(t), get<0>(t));
			} else {
				c1.update_chromosome(get<1>(t), get<0>(t));	
 				c2.update_chromosome(get<2>(t), get<0>(t));
			}
		}
	}
}

\end{lstlisting}
\end{minipage}
\subsubsection{Edge-Recombination-Crossover}
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Edge-Recombination-Crossover}, firstnumber=1, captionpos=b, label=lst:erx]
bool edge_recombination_crossover(Individual &p1, Individual &p2, Individual &c1, Individual &c2) {
	map<int, set<int>> edge_map = create_edge_map(p1, p2);
	edge_recombination(p1.get_chromosome().at(0),c1, edge_map);
	edge_recombination(p2.get_chromosome().at(0),c2, edge_map);
	return true;
}

void edge_recombination(int start, Individual &i, map<int, set<int>> edge_map) {
	int current = start;
	for (int idx = 0; idx < i.get_size() - 1; ++idx) {
		i.update_chromosome(current, idx);
		for (auto &it : edge_map) {
			it.second.erase(current);
		}
		int min_next_idx = -2;
		unsigned int min_next_count = numeric_limits<int>::max();

		for (int node : edge_map.at(current)) {
			if (edge_map.at(node).size() < min_next_count) {
				min_next_count = edge_map.at(node).size();
				min_next_idx = node;
			}
		}
		current = min_next_idx;
		if (idx == i.get_size() - 2) {
			i.update_chromosome(current, idx + 1);
		}
	}
}
\end{lstlisting}
\end{minipage}

\subsection{Mutations-Algorithmus}
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Delete-Shift-Mutaions-Algorithmus}, firstnumber=1, captionpos=b, label=lst:mutation]
bool mutation_delete_shift(Individual &individual, int percentage) {
	bool mutate = rand(100)  < percentage;
	if (mutate) {
		int position_a = rand(individual.get_size() - 1);
		int position_b = rand(position_a + 1, individual.get_size());
 
		for (int i = position_a; i < position_b; i++) {
			swap_chromosome(individual.get_chromosome(), i, i + 1);
		}
	}
	return mutate;
}
\end{lstlisting}
\end{minipage}
\subsection{Selektions-Algorithmus}
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Survival-Of-The-Fittest-Selektions-Algorithmus}, firstnumber=1, captionpos=b, label=lst:selektion]
Population selection_sotf(Population &p_old, Population &p_new) {
	int size = (int) p_old.size();
	p_old.calc_population_fitness();
	p_new.calc_population_fitness();
	Population result = Population(p_old.get_idx_start(), p_old.get_distances());

	vector<Individual> individuals_old = p_old.get_individuals();
	vector<Individual> individuals_new = p_new.get_individuals();

	sort(individuals_new.rbegin(), individuals_new.rend());
	sort(individuals_old.rbegin(), individuals_old.rend());
	int offset_old = 0;
	int offset_new = 0;
	for (int i = 0; i < size; ++i) {
		if (individuals_old.at(offset_old) < individuals_new.at(offset_new)) {
			result.add_individual(individuals_new.at(offset_new));
			offset_new++;
		} else {
			result.add_individual(individuals_old.at(offset_old));
 			offset_old++;
		}
	}
	return result;
}
\end{lstlisting}
\end{minipage}
\subsection{Simulator}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img/Vortrag/simulator.png}
\caption{Klassendiagramm Simulator}
\label{fig:simulator}
\end{figure}

\subsection{Python-Schnittstelle}
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={C++ zu Python Schnittstelle}, firstnumber=1, captionpos=b, label=lst:boostpython]
BOOST_PYTHON_MODULE(Simulator_Wrapper)
{
	to_python_converter<tuple<int, int, int>, TupleToList<int> >();

	enum_<Selection_Algorithm>("Selection_Algorithm").value("SOTF", Selection_Algorithm::SOTF);

	class_<Simulator>("Simulator", init<
		string, string, string,
		int,int,int,int,
		Crossover_Algorithm, Marriage_Algorithm, Mutation_Algorithm, Selection_Algorithm>(
		))
 		.def("simulate", &Simulator::simulate)
		.def("finished", &Simulator::finished)
		.def("best_individual", &Simulator::best_individual);
}
\end{lstlisting}
\end{minipage}
\subsection{Testen}
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Unit-Tests}, firstnumber=1, captionpos=b, label=lst:tests]
SCENARIO("Test Individual initialization", "[Individual.cpp]")
{
	for (int i = 0; i < 100; ++i) {
		Individual individual = Individual(size, idx_start, nullptr, nullptr);
		vector<int> chromosome = individual.get_chromosome();
		REQUIRE(chromosome.size() == (unsigned int) size);
		REQUIRE(unique(chromosome.begin(), chromosome.end()) == chromosome.end());
	}
}
\end{lstlisting}
\end{minipage}
%--